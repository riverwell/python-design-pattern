# Bridge
* 「機能のクラス階層」と「実装のクラス階層」の橋渡しをする

## 何故Bridgeを使うか
### クラス階層の2つの役割
#### 新しい機能を追加したい時には,,,
* あるクラスSomethingに新しい機能(メソッド)を追加したいとき，サブクラスとしてSomethingGoodクラスを作る
* ここで，小さなクラス階層ができる
    * これは機能を追加するために作られた階層
        * スーパークラスは基本的な機能を持っている
        * サブクラスで新しい機能を追加する
    * このクラス階層を「機能のクラス階層」と呼ぶ
        * 新しい機能を追加したいと思った時に，クラス階層の中から自分の目的に近いクラスを探し出し，そのサブクラスを作り，目的の機能を追加した新しいクラスを作ること
* 一般にクラス階層はあまり深くしすぎないほうがいいと言われる

#### 新しい「実装」を追加したい時には，，，
* スーパークラスとサブクラスの役割分担で，部品としての価値(交換可能性)が高いクラスを作ることが出来た
* ここでも，スーパークラスAbstractClassの抽象メソッドを実装したサブクラスConcreteClassとの間に，小さなクラス階層が作られる
* ここでは，次のような役割分担のためにクラス階層が使われている
    * スーパークラスは抽象メソッドにヨテインターフェイス(API)を規定している
    * サブクラスは具象メソッドによってそのインターフェイス(API)を実装する
* このクラス階層を「実装のクラス階層」と呼ぶ

#### クラス階層の混在とクラス階層の分離
* よし，サブクラスを作ろうと鳴った時，自分の意図を次のように確認する必要がある
    * 私は，機能を追加しようとしているのかな？
    * それとも，実装を行おうとしているのかな？
* クラス階層が1つだと，機能のクラス階層と実装のクラス階層が1つの階層構造の中に混在することになる
* これはクラス階層を複雑にし，見通しを悪くしてしまう恐れがある
* そこで，「機能のクラス階層」と「実装のクラス階層」を **2つの独立したクラス階層に分けてしまう**
* 単に分けただけではバラバラになるので，その2つのクラス階層の間に橋渡しをすることが必要
* サンプルプログラムを読むおt器は，必ず **「2つのクラス階層」を意識しながら読むこと**

## Bridgeパターンの登場人物
* Abstraction(抽象化)の役
    * 「機能のクラス階層」の最上位クラス
    * Implementor役のメソッドを使って基本的な機能だけが記述されているクラス
    * このインスタンスはImlementor役を保持する
    * Displayクラスがこの役
* RefinedAbstraction(改善した抽象化)の役
    * Abstraction役に対して機能を追加した役
    * CountDisplayクラスがこの役
* Implementor(実装者)の役
    * 「実装のクラス階層」の最上位のクラス
    * Abstraction役のインターフェイス(API)を実装するためのメソッドを規定する役
    * DisplayImplクラスがこの役
* ConcreteImplementor(具体的な実装者)の役
    * 具体的にImplementor役のインタフェース(API)を実装する役
    * StringDisplayImplクラスがこの役

## あなたの考えを広げるためのヒント
### 分けておけば拡張するのが楽になる
* 2つのクラス階層を分けておけば，それぞれのクラス階層を独立に拡張することができる
* また， 機能を追加したとき実装のクラス階層は全く修正する必要はなく， **追加した機能は「すべての実装」で利用できる**
    * 例えば，実装のクラス階層をOSに当てはめる
    * あるプログラムにOS依存の部分があった場合，依存部分をBridgeパターンの「実装のクラス階層」で表現する
    * つまり，各OS共通のインタフェース(API)を決めてImplementor役とし，ConcreteImplementor役としてWindows版，Mac版，Linux版を作る
    * こうすれば，「機能のクラス階層」でいくら機能を追加しても，3つのOSに同時に対応していることになる

### 継承は固い結びつき，委譲はゆるやかな結びつき
* クラスを継承した場合，スーパークラスとサブクラスの **関係はソースコードを書き換えない限り変えられない**
* プログラムの必要に応じてカチカチとクラス間の関係を切り替えたいときには，継承を使うのは不適切
* このようなときは，継承でなく委譲を使う
* サンプルプログラムではDisplayクラスの中で委譲が使われている
    * implを保持して，
        * openを実行するときには，impl.raw_open()を呼び出す
    * ようにたらい回しにする
    * 仕事をやれ，と言われたら，implくんにおまかせしている，というのが委譲
* 複数のクラス設計を行なう時は，このことを理解しておく必要がある
