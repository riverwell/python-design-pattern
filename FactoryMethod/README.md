# FactoryMethodパターン
* インスタンスを生成する工場をTemplateMethodパターンで構成したもの
    * インスタンスの作り方をスーパークラスで定めるが，具体的なクラス名は定めない
    * 具体的な肉付けは，すべてサブクラスの側で行なう
    

## 何故FactoryMethodを使うか
* これにより，インスタンス生成のための枠組み(フレームワーク)と，実際のインスタンス生成のクラスを分けて考えることができる
* 例での工場
    * createメソッドでProductのインスタンスを生成するもの

## FactoryMethodパターンの登場人物
* 登場人物は，2つのサイドに分けられる
    * スーパークラス(抽象的な枠組み，フレームワーク)側にあるCreator役，Product役
    * サブクラス(具体的な肉付け)側にあるConcreteCreator約とConcreteProduct約
    
* Product(製品)の役
    * 生成されるインスタンスが持つべきインターフェイス(API)を定める抽象クラス
    * Productクラスが該当
* Creator(作成者)の役
    * Product役を生成する抽象クラス
    * Factoryクラスが該当
    * Creator役は作成するConcreteProduct役については何も知らない
        * 知っているのはProduct役とインスタンス生成のメソッド(例ではcreate_product)を呼び出せばProduct役が生成されるということだけ
        * **newによる実際のインスタンス生成を，インスタンス生成のためのメソッド呼び出しに代えることで，具体的なクラス名による束縛からスーパークラスを解放していることになる**

* ConcreteProduct(具体的製品)の役
    * 具体的な製品を定める役
    * IDCardクラスが該当

* ConcreteCreator(具体的作成者)の役
    * 具体的な製品を作るクラスを定める
    * IDCardFactoryクラスが該当
 
 ## あなたの考えを広げるためのヒント
 ### フレームワークと肉付け
 * フレームワークと肉付けの2つの側について説明した
 * ここで，同じフレームワークを使って全く別の製品と工場を作る場合，frameworkパッケージを全く修正せずに，作ることができる
 * これはframeworkパッケージが，具体的なパッケージに依存していないため
 
### インスタンス生成-メソッドの実装方法
* サンプルのcreate_productの記述方法は次の3通りが考えられる
    * 抽象メソッドにする
        * サブクラスでの実装を強制
    * デフォルトの実装を用意しておく
        * サブクラスで実装しなかった場合デフォルトの実装を使う
    * エラーにする
        * raiseを宣言しておき，サブクラスで実装しなかった場合，実行時にエラーを吐かせる
### パターン利用と開発者間の意思疎通
* デザインパターンを使ってクラス群を設計する場合，そのクラス群の保守を行う人に，設計者の意図したデザインパターンが何であるか上手く伝わるようにする必要がある
    * そうでないと，設計者の最初の意図と離れた修正が行われるから
* プログラムのコメントや開発文書中に，実際に使われているデザインパターンの名称と意図を記述しておくと良い

## この章で学んだこと
* 1つのクラスだけを取り上げて，これがどのパターンか，というのでなく，必ずクラスやインタフェースの相互関係に目を向けるようにする
    * 白雪姫が1人立っていても，白雪姫の劇にならない