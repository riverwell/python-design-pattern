# Chain of Responsibility
* 責任をたらい回しする
    * 要求を処理するインスタンスを鎖状に並べておき，要求を処理できるかどうかを順番にチェックしていく

## 何故Chain of Responsibilityを使うか
* ある要求が発生した時に，その要求を処理するオブジェクトをダイレクトに決められない場合
* 複数のオブジェクトを鎖(Chain)のように繋いでおき，そのオブジェクトのくさるを順次渡り歩いて，目的のオブジェクトを決定する

## Chain of Responsibilityパターンの登場人物
* Handler(処理者)の役
    * 要求を処理するインタフェース(API)を定める役
    * 「次の人」を保持しておき，自分で処理ができない要求が来たら，その人にたらい回しする
    * Supportクラスがこの役
        * 要求を処理するメソッドはsupport
* ConcreteHandler(具体的処理者)の役
    * 要求を処理する具体的な役
    * NoSupport,LimitSupport,OddSupport,SpecialSupportがこの役
* Client(要求者)の役
    * 最初のConcreteHandler役に要求を出す役
    * Mainクラスがこの役


## あなたの考えを広げるためのヒント
### 要求を出す人と要求を処理する人をゆるやかに結びつける
* このパターンを使わないと，この要求はこの人が処理すべし，という知識を誰かが中央集権的に持っている必要がある
* その知識を要求を出す人に持たせると，その人が処理者たちの役割分担の詳細まで知る必要になり，部品としての独立性が損なわれる

### 動的に連鎖の形態を帰る
* 委譲によって盥回ししていれば，状況の変化に応じてConcreteHandler役を組み替えられる
    * ユーザがウィンドウ上にコンポーネント(ボタンやテキスト入力フィールド)を自由に追加できる場合など

### 自分の仕事に集中できる
* たらい回しできれば，自分の仕事に集中できる

### たらい回しで処理は遅くならないのか？
* 柔軟性は高いが，処理が遅くなる
* トレードオフなので，要求と処理者の関係が固定的で，処理速度が非常に重要ならChain of Responsibilityパターンは使わない方が有効
