# Strategy
* アルゴリズムを実装した部分をごっそり交換する
* 同じ問題を別の方法で解くのを容易にするパターン

## 何故Strategyを使うか
* Strategyはプログラミングにおいては「アルゴリズム」と考えてよい


## Strategyパターンの登場人物
* Strategy(戦略)の役
    * 戦略を利用するためのインタフェース(API)を定める役
    * Strategyインタフェースがこの役
* ConcreteStrategy(具体的戦略)の役
    * Strategy役のインタフェース(API)を実際に実装する役
    * ここで具体的な戦略(作戦・方策・方法・アルゴリズム)を実際にプログラミングする
    * WinningStrategyクラスとProvStrategyクラスがこの役
* Context(文脈)の役
    * Strategy役を利用する役
    * ConcreteStrategy役のインスタンスを持っていて，必要に応じてそれを利用する
    * Playerがこの役


## あなたの考えを広げるためのヒント
### わざわざStrategy役を作る必要ってあるの？
* Strategyパターンでは，アルゴリズムの部分を他の部分と意識的に分離する
* そしてアルゴリズムとのインタフェース（API）部分だけを規定
* そして，プログラムから委譲によってアルゴリズムを利用する
* 例えば，アルゴリズムを高速化したい場合など，ConcreteStrategy役だけをいじる(速度比較する場合や，CPUの難易度を変える場合も)
* **委譲というゆるやかな結びつきを使っているので，アルゴリズムを容易に切り替えられる**

### 実行中に切り替えることも可能
* メモリが少ない環境とメモリが多い環境でアルゴリズムを切り替えるなども出来る
* 片方のアルゴリズムを他方のアルゴリズムの検算にも使える
    * バグがあるかもしれない高速なアルゴリズムの検算に，低速だが確実な計算を行なうアルゴリズムを用意するなど

## 注意
player1の勝率が高すぎておかしい
どっかバグってるはず

